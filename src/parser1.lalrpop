use std::str::FromStr;
use ast::{Expr, Statement};
use value::Value;
use std::collections::HashMap;

grammar<'c>(constants: &'c mut HashMap<String, usize>, constant_pool: &'c mut Vec<Value>);

Semi<T>: Vec<T> = { // (0)
    <v:(<T> ";")*> <e:T?> => match e { // (1)
        None=> v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

Tier<Op,NextTier>: Box<Expr> = {
    <left: Tier<Op,NextTier>> <operator: Op> <right: NextTier> => Box::new(Expr::Binary{<>}),
    NextTier
};

pub Program = Declaration*;

Declaration = {
    VariableDeclaration,
    Statement,
};

VariableDeclaration: Statement = {
    "var" <i: Identifier> <initializer:("=" <Expr> )?> ";" => {
        let name = i.to_string();
        Statement::Var { name, initializer }
    }
};

Statement = {
    ExprStatement,
    PrintStatement,
    Block,
};

ExprStatement: Statement = {
    <expression: Expression> ";" => Statement::Expression{<>}
};

PrintStatement: Statement = {
    "print" <expression: Expression> ";" => Statement::Print{<>}
};

Block: Statement = {
    "{" <statements: Declaration*> "}" => Statement::Block{<>}
};

Expression = {
    Assignment
};

Assignment: Box<Expr> = {
    <name: Identifier> "=" <v: Assignment> => {
        Box::new(Expr::Assign {name: name.to_string(), value: v})
    },
    Expr
};

Expr = Tier<ExprOp, Factor>;
Factor = Tier<FactorOp, Term>;

ExprOp: String = { // (3)
    "+" => "+".to_string(),
    "-" => "-".to_string(),
};

FactorOp: String = {
    "*" => "*".to_string(),
};

Term: Box<Expr> = {
    Literal => Box::new(Expr::Literal{value: <>}),
    <i: Identifier> => Box::new(Expr::Variable{name: i.to_string()}),
    "(" <Expr> ")"
};

Literal: usize = {
    <s: r"[0-9]+"> => {
        let idx = constants.entry(s.to_string()).or_insert_with(|| {
            let v = Value::Number(i32::from_str(<>).unwrap());
            let i = constant_pool.len();
            constant_pool.push(v);
            i
        });
        *idx
    },
    <s:r#""[^"]*""#> => {
        let literal = s[1..s.len()-1].to_string();
        let idx = constants.entry(literal.clone()).or_insert_with(|| {
            let v = Value::String(literal);
            let i = constant_pool.len();
            constant_pool.push(v);
            i
        });
        *idx
    },
    "true" => {
        let idx = constants.entry("true".to_string()).or_insert_with(|| {
            let v = Value::Bool(true);
            let i = constant_pool.len();
            constant_pool.push(v);
            i
        });
        *idx
    },
    "false" => {
        let idx = constants.entry("false".to_string()).or_insert_with(|| {
            let v = Value::Bool(false);
            let i = constant_pool.len();
            constant_pool.push(v);
            i
        });
        *idx
    },
};


Identifier: &'input str = r"[a-zA-Z][a-zA-Z0-9_]*" => <>;
